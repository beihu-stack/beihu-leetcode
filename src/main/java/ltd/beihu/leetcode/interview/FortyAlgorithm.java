package ltd.beihu.leetcode.interview;

import javax.swing.tree.TreeNode;

/**
 * 40个算法题
 *
 * @author Adam
 * @date 2020/7/11
 */
public class FortyAlgorithm {

    /**
     * 15. 三个数之和
     * 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
     *
     * 注意：答案中不可以包含重复的三元组。
     *
     * 解决方案：
     *      方案一：暴力O(n3)
     *      方案二：用一个set存储所有数，两层循环，看 -(a+b) 是否在set中 O(n2)
     *      方案三：先排序，然后一层循环a，在每次循环里面对后续元素进行双端压缩查找和为-a的原始，指针转换  （忽略）
     */


    /**
     * 树：左小中右大
     * 二叉搜索树：平均复杂度 O(logn)，最坏复杂度 O(n) - 即只有小元素或只有大元素，一直排成一链
     * 二叉平衡数：
     *      红黑树：
     *      Splay Tree：
     *      AVL Tree：
     * KD Tree：
     *
     * 前中后续遍历主要看跟节点的位置
     *      前：根左右
     *      中：左根右
     *      后：左右根
     */

    /**
     * 98. 验证二叉搜索树
     * 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
     * 假设一个二叉搜索树具有如下特征：
     *      节点的左子树只包含小于当前节点的数。
     *      节点的右子树只包含大于当前节点的数。
     *      所有左子树和右子树自身必须也是二叉搜索树。
     * 示例 1:
     *
     * 输入:
     *     2
     *    / \
     *   1   3
     * 输出: true
     * 示例 2:
     *
     * 输入:
     *     5
     *    / \
     *   1   4
     *      / \
     *     3   6
     * 输出: false
     * 解释: 输入为: [5,1,4,null,null,3,6]。
     *      根节点的值为 5 ，但是其右子节点值为 4 。
     *
     * 解决方案：
     *      方案一：中序遍历，遍历后的数组是否为升序的序列，只需要保留前继节点 O(n)
     *      方案二：递归 左右节点
     *          复杂度：每个节点访问且只访问一次 O(n)
     *
     */
    public boolean isValidBST(TreeNode root) {
        return false;
    }

    /**
     * 235. 二叉搜索树的最近公共祖先 - 可更块
     * 236. 二叉树的最近公共祖先
     *
     * 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
     * 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
     *
     * 解决方案：
     *      方案一：路径path寻找，从上往下，标记路径 ，寻找重合原始 O(n)
     *      方案二：递归
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return null;
    }

}